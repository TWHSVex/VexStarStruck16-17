#pragma config(Sensor, dgtl1,  frontRight,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  frontLeft,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  backRight,      sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  backLeft,       sensorQuadEncoder)
#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port3,           frontLeft,     tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port4,           backRight,     tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port5,           backLeft,      tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port6,           cTopRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           cTopLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           cMiddle,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           cBottom,       tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#define C1LX vexRT[Ch4]
#define C1LY vexRT[Ch3]
#define C1RX vexRT[Ch1]
float target = 12; //Inches
float diameter = 3.5;

float circum= PI*diameter;
float rot = target/circum;
float targetticks = rot*360/sqrt(2);


//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{


	SensorValue[frontLeft] = 0;
	SensorValue[frontRight] = 0;
	SensorValue[backLeft] = 0;
	SensorValue[backRight] = 0;
 //targetticks = (12/(3.5*PI))*360;

	while(abs(SensorValue(frontLeft)) < targetticks)
	{
		motor[frontLeft]=127;
		motor[frontRight]=127;
		motor[backLeft]=127;
		motor[backRight]=127;
		wait1Msec(3000);
	}
		motor[frontLeft]=0;
		motor[frontRight]=0;
		motor[backLeft]=0;
		motor[backRight]=0;
}



task usercontrol()
{

	while (true)
	{



		//Forwards and Backwards


		motor[frontRight]=-vexRT[Ch4]+vexRT[Ch1]+vexRT[Ch3];
		motor[frontLeft]=vexRT[Ch4]+vexRT[Ch1]+vexRT[Ch3];
		motor[backLeft]=-vexRT[Ch4]-vexRT[Ch1]+vexRT[Ch3];
		motor[backRight]=vexRT[Ch4]+vexRT[Ch1]+vexRT[Ch3];


		clearTimer(T1);

		SensorValue[frontLeft] = 0;
		SensorValue[frontRight] = 0;
		SensorValue[backLeft] = 0;
		SensorValue[backRight] = 0;
		float time = 6;
		wait1Msec(time);
		float speedfl = SensorValue[frontLeft];  //Rotational Speed of each motor
		float speedfr = SensorValue[frontRight];
		float speedbl = SensorValue[backLeft];
		float speedbr = SensorValue[backRight];
		writeDebugStreamLine("speed", speedfl);
		writeDebugStreamLine("speed", speedfr);
		writeDebugStreamLine("speed", speedbl);
		writeDebugStreamLine("speed", speedbr);
		float smallest = speedfl;
		float shaftSpeeds[4] = {speedfl, speedfr, speedbl, speedbr};
		for(int i = 1; i < 4; i++){ //Compare each motors Speed and set smallest equal to float smallest
			if(smallest > shaftSpeeds[i]){
				smallest = shaftSpeeds[i];
			}
		}
		if(speedfl>smallest)
		{
			motor[frontLeft]= motor[frontLeft]-1;
		}
		if(speedfr>smallest)
		{
			motor[frontRight]= motor[frontRight]-1;
		}
		if(speedbl>smallest)
		{
			motor[backLeft]= motor[backLeft]-1;
		}
		if(speedbr>smallest)
		{
			motor[backRight]= motor[backRight]-1;
		}
		if(vexRT[Btn5D]==1)
		{
			motor[cTopRight]=128;
			motor[cTopLeft]=128;
			motor[cMiddle]=128;
			motor[cBottom]=128;
		}
		else if(vexRT[Btn5U]==1)
		{
			motor[cTopRight]=-128;
			motor[cTopLeft]=-128;
			motor[cMiddle]=-128;
			motor[cBottom]=-128;
		}
		else
		{
			motor[cTopRight]=0;
			motor[cTopLeft]=0;
			motor[cMiddle]=0;
			motor[cBottom]=0;
		}


	}
}
